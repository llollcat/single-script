./instructions.txt:
	Инструкция для LLM. 

	Задача:
	- На основе существующего модуля modules/onBeforeLiveAfterExample/sinsmod.sh создать новый модуль.
	- Модуль должен полностью реализовывать функционал через доступные интерфейсы: before, live, after, holiday.
	- Изначальные комментарии и неиспользуемые функции (например, on_init) можно удалить.
	- Не добавлять лишние пункты меню, если они не нужны.
	- Модуль должен иметь минимальное количество зависимостей; при необходимости допустимо добавить.

	Требования к модулю:
	1. Папка модуля находится в modules.
	2. В корне папки должен быть файл sinsmod.sh.
	3. Меню модуля задаётся массивом MENU_ITEMS.
	4. Основная обработка выполняется в функции on_menu, которая вызывает соответствующие функции этапов:
	   - on_pre_*
	   - on_*
	   - on_post_*
	Данный скрипт на bash позволяет фиксировать изменения в системе. Этапы before и after являются одинаковыми и разница лишь в их последовательности, данные этапы делают что-то вроде снимка в конкретный момент времени. Этап live предназначен для получения метрик в течении какого-то времени.
	
	Рекомендации по реализации:
	- Использовать интерфейсы before/live/after для выполнения операций.
	- on_live не должен блокировать поток управления: запускать процессы в фоне и завершать в on_post_live.
	- Для before/after блокировка допустима.
	- Для этапа holiday использовать функции on_pre_holiday, on_holiday, on_post_holiday.
	- При создании папки метрик использовать create_metric_folder.
	- Функция on_update_ask должна проверять возможность обновления модуля.

	Глобальные переменные и функции, доступные модулю:
	- METRICS_DIR, MENU_ITEMS, MODULES_DIR
	- main, on_init, on_update_ask, on_menu, on_pre_holiday, on_holiday, on_post_holiday
	- on_pre_before, on_before, on_post_before
	- on_pre_live, on_live, on_post_live
	- on_pre_after, on_after, on_post_after
	- pause, create_metric_folder, run_modules_func

	Остальную информацию и примеры можно получить просмотрев файлы.

./singleScript.sh:
	#!/bin/bash

	SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
	cd "$SCRIPT_DIR" || exit 1

	METRICS_DIR="$PWD"
	MODULES_DIR="$PWD/modules"




	# запуск функций с переданным именем из всех модулей.
	function run_modules_func() {
		local func="$1"
		for mod in $MODULES_DIR/*/sinsmod.sh; do
			[[ -f "$mod" ]] || continue
			(
				pushd "$(dirname "$mod")" >/dev/null
				source "$mod"
				if declare -F "$func" > /dev/null; then
					$func
				fi
				popd >/dev/null
			)
		done
	}

	# создание папки метрик с заданым именем
	function create_metric_folder() {
		local base_name="$1"
		
		if ! [ -d "${PWD}/${base_name}" ]; then
			METRICS_DIR="${PWD}/${base_name}"
		else
			counter=1
			while [ -d "${PWD}/${base_name}${counter}" ]; do
				((counter++))
			done
			METRICS_DIR="${PWD}/${base_name}${counter}"
		fi
		
		mkdir $METRICS_DIR
		chmod 777 $METRICS_DIR
	}

	# прерывание
	function pause() {
		local message="$1"
		# Очистить весь буфер ввода
		while read -t 0.1 -n 1000 dummy; do
			: #
		done
		read -n 1 -s -r -p "${message}"
		echo -e "\n"
	}

	# Базовый спиннер
	spinner() {
		local pid=$1
		local chars='|/-\'
		local i=0
		while kill -0 "$pid" 2>/dev/null; do
			printf "\r%c" "${chars:i++%${#chars}:1}"
			sleep 0.1
		done
		printf "\r"
	}



	menu_action=()
	function_path=()


	function main(){
		if [ -z "$STDBUF_APPLIED" ]; then
			export STDBUF_APPLIED=1
			exec stdbuf -oL -eL "$0" "$@"
		fi
		
		
		if [[ "$EUID" -ne 0 ]]; then
			echo запрос повышения прав...
			exec sudo "$0" "$@"
		fi
		
		if [ -z "$TMUX" ]; then
			if command -v tmux &> /dev/null; then
				exec tmux new-session -A -s sins "$0"
			else
				echo tmux не установлен.
				echo Рекомендуется запустить скрипт в сессии tmux.
			fi
		fi
		
		
		
		
		chmod -R 777 $MODULES_DIR/*
		
		echo "$MODULES_DIR/*/sinsmod.sh"
		#on_init execute
		for mod in $MODULES_DIR/*/sinsmod.sh; do
			[[ -f "$mod" ]] || continue
			(
				pushd "$(dirname "$mod")" >/dev/null
				source "$mod"
				if declare -F "on_init" > /dev/null; then
					on_init
					if [ $? -eq 3 ]; then
						exit 3
					fi
				fi
				popd >/dev/null
			)
			if [ $? -eq 3 ]; then
				echo "Не работает важный модуль"
				exit 3
			fi
		done
		
		#MENU_ITEMS добавление
		menu_item_number=1
		for mod in $MODULES_DIR/*/sinsmod.sh; do
			[[ -f "$mod" ]] || continue
			
			unset MENU_ITEMS
			source "$mod"
			
			if [[ -v MENU_ITEMS ]]; then
				for ((i=0; i<${#MENU_ITEMS[@]}; ++i)); do
					
					menu_action+=("$menu_item_number")
					menu_action+=("${MENU_ITEMS[i]}")
					
					function_path+=("$menu_item_number")
					function_path+=("$mod")
					
					((++menu_item_number))
				done
				unset MENU_ITEMS
			fi
		done
		
		#Основной цикл
		while true; do
			for ((i=0; i<${#menu_action[@]}; i+=2))
			do
				if [ $((i+1)) -lt ${#menu_action[@]} ]; then
					echo "${menu_action[i]}: ${menu_action[i+1]}"
				fi
			done
			echo "0: Выход"
			read -p "Выберите опцию: " CHOICE
			if [[ "$CHOICE" -eq 0 ]]; then
				echo Завершение...
				exit 0
			fi
			(
				menu_item_num=$(( (CHOICE-1)*2 + 1 ))
				pushd "$(dirname "${function_path[menu_item_num]}")" >/dev/null
				
				$func
				popd >/dev/null
				source "${function_path[menu_item_num]}"
				on_menu "${menu_action[menu_item_num]}"
				
			)
		done
	}
	main
./modules/beforeLiveAfter/sinsmod.sh:
	#!/bin/bash

	MENU_ITEMS=("Снятие Before, Live, After" "Снятие Before, Live, After на праздничную дату" "Снятие только Live, After" "Снятие только After" "Проверить обновления модулей")
	function on_menu(){
		local menu_item="$1"
		
		folder_created=false
		case $menu_item in
			"Снятие Before, Live, After на праздничную дату")
				create_metric_folder "metric_holiday"
				folder_created=true
				
				run_modules_func on_pre_holiday
				
				run_modules_func on_holiday
				
				run_modules_func on_post_holiday
				;&
				"Снятие Before, Live, After")
					if [ "$folder_created" = "false" ]; then
						create_metric_folder "metric"
						folder_created=true
					fi
					run_modules_func on_pre_before
					
					echo -e "Before запущен... " $(date +"%H:%M:%S %d-%m-%Y") "\n"
					run_modules_func on_before
					
					run_modules_func on_post_before
					
					pause "Для начала снятия Live нажмите Enter:"
					;&
					"Снятие только Live, After")
						if [ "$folder_created" = "false" ] ; then
							create_metric_folder "metric"
							folder_created=true
						fi
						run_modules_func on_pre_live
						
						echo -e "Live запущен... " $(date +"%H:%M:%S %d-%m-%Y") "\n"
						run_modules_func on_live
						
						pause "Для завершения снятия Live нажмите Enter:"
						
						run_modules_func on_post_live
						
						;&
						
						"Снятие только After")
							if [ "$folder_created" = "false" ]; then
								create_metric_folder "metric"
								folder_created=true
							fi
							run_modules_func on_pre_after
							
							echo -e "After запущен... " $(date +"%H:%M:%S %d-%m-%Y") "\n"
							run_modules_func on_after
							
							run_modules_func on_post_after
						;;
						
						"Проверить обновления модулей")
							run_modules_func on_update_ask
						;;
						*)
							echo "Неизвестная команда"
						;;
		esac
	}
	
./modules/onBeforeLiveAfterExample/sinsmod.sh:
	#!/bin/bash

	# не использованные функции можно удалить из полученного модуля

	# значения возврата:
	# return 0 - модуль готов к использованию
	# return 1 - модуль / часть модуля может быть использован в ограниченном функционале
	# return 2 - модуль не может быть использован
	# return 3 - модуль не может быть использован, является критической частью. Требуется остановка всего скрипта.


	# Вызывается всегда при первом вызове модуля. Используется для установки / инициализации / проверке работоспособности модуля и т.п.
	function on_init() {
		return 0
	}

	# Функция проверки обновления
	function on_update_ask() {
		return 0
	}

	MENU_ITEMS=() # к примеру MENU_ITEMS=("действие 1" "действие 2")
	function on_menu(){
		local menu_item="$1"
		#Пример реализации
		#   case $menu_item in
		#   "действие 1")
		#       ;;
		#   "действие 2")
		#       ;;

	}

	###### Остальные функции срабатывают соответственно названиям событий в следующем порядке holiday -> before -> live -> after
	# on_pre_*  - Подготовка перед этапом. Добавлено на всякий случай. Рекомендации к использованию не определены.
	# on_*      - Основной этап. Модуль НЕ ДОЛЖЕН блокировать весь поток управления в on_live этапе. Стоит запустить необходимые процессы в фоне и затем завершить их в on_post_*. В остальных этапах блокировка допустима.
	# on_post_* - Последний этап. Рекомендуется использовать для остановки / окончания этапа
	########################

	function on_pre_holiday() {
		return 0
	}

	function on_holiday() {
		return 0
	}

	function on_post_holiday() {
		return 0
	}


	function on_pre_before() {
		return 0
	}

	function on_before() {
		return 0
	}

	function on_post_before() {
		return 0
	}


	function on_pre_live() {
		return 0
	}

	# Модуль НЕ ДОЛЖЕН блокировать весь поток управления в on_live этапе!
	function on_live() {
		return 0
	}

	function on_post_live() {
		return 0
	}


	function on_pre_after() {
		return 0
	}

	function on_after() {
		return 0
	}

	function on_post_after() {
		return 0
	}